import { chmod, mkdir, stat } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import Bun from "bun";

export interface InstallServiceOptions {
  configPath: string;
  serviceName?: string;
  serviceUser?: string;
  serviceGroup?: string;
  workingDir?: string;
  bunBinary?: string;
  servicePath?: string;
  enableCapNetBind?: boolean;
  additionalArgs?: string[];
  env?: Record<string, string>;
  force?: boolean;
  dryRun?: boolean;
}

export interface InstallServiceResult {
  servicePath: string;
  execStart: string;
  enabled: boolean;
  started: boolean;
}

const DEFAULT_SERVICE_NAME = "reverse-proxy";

function ensureLinux() {
  if (process.platform !== "linux") {
    throw new Error("Systemd installation is only supported on Linux hosts.");
  }
}

async function ensureFileExists(path: string): Promise<void> {
  try {
    await stat(path);
  } catch (error) {
    throw new Error(`Expected file at ${path}, but it was not found.`);
  }
}

async function detectSystemctl(): Promise<string> {
  const found = await Bun.which("systemctl");
  if (!found) {
    throw new Error("systemctl command not found. Is this a systemd-based system?");
  }
  return found;
}

async function resolveBunBinary(path?: string): Promise<string> {
  if (path) {
    const candidate = Bun.file(path);
    if (!(await candidate.exists())) {
      throw new Error(`Bun binary not found at ${path}`);
    }
    return path;
  }
  const detected = await Bun.which("bun");
  if (detected) return detected;
  throw new Error("Unable to locate bun binary. Pass --service-binary to specify the path.");
}

function formatEnv(key: string, value: string): string {
  const pair = `${key}=${value}`;
  if (/\s|"|'/u.test(pair)) {
    const escaped = pair.replace(/"/g, '\\"');
    return `Environment="${escaped}"`;
  }
  return `Environment=${pair}`;
}

function quote(arg: string): string {
  if (/^[A-Za-z0-9@%_+=:,./-]+$/u.test(arg)) {
    return arg;
  }
  return `'${arg.replace(/'/g, "'\\''")}'`;
}

function buildUnitFile(options: {
  serviceName: string;
  serviceUser: string;
  serviceGroup: string;
  workingDir: string;
  env: Record<string, string>;
  execArgs: string[];
  enableCapNetBind: boolean;
}): string {
  const envEntries: string[] = [];
  for (const [key, value] of Object.entries(options.env)) {
    envEntries.push(formatEnv(key, value));
  }

  if (envEntries.length === 0) {
    envEntries.push("Environment=NODE_ENV=production");
  }

  const execStart = options.execArgs.map(quote).join(" ");

  const capLines = options.enableCapNetBind
    ? [
        "# Allow binding to privileged ports",
        "AmbientCapabilities=CAP_NET_BIND_SERVICE",
        "CapabilityBoundingSet=CAP_NET_BIND_SERVICE",
        "NoNewPrivileges=true",
      ]
    : [];
  const capBlock = capLines.length ? `${capLines.join("\n")}\n` : "";

  return `# Auto-generated by reverse-proxy install\n
[Unit]
Description=Bun Reverse Proxy (host-based HTTP router)
Wants=network-online.target
After=network-online.target

[Service]
User=${options.serviceUser}
Group=${options.serviceGroup}
WorkingDirectory=${options.workingDir}
${envEntries.join("\n")}

ExecStart=${execStart}
Restart=always
RestartSec=2
KillSignal=SIGINT
TimeoutStopSec=15
SyslogIdentifier=${options.serviceName}
${capBlock}LimitNOFILE=65536
ProtectSystem=full
ProtectHome=false
PrivateTmp=true
PrivateDevices=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
LockPersonality=true

[Install]
WantedBy=multi-user.target
`;
}

export async function installSystemdService(rawOptions: InstallServiceOptions): Promise<InstallServiceResult> {
  ensureLinux();

  if (typeof process.getuid === "function" && process.getuid() !== 0) {
    throw new Error("Installing as a service requires root privileges. Re-run with sudo.");
  }

  const configPath = resolve(rawOptions.configPath);
  await ensureFileExists(configPath);

  const serviceName = rawOptions.serviceName ?? DEFAULT_SERVICE_NAME;
  const serviceUser = rawOptions.serviceUser ?? Bun.env.SUDO_USER ?? Bun.env.USER ?? "root";
  const serviceGroup = rawOptions.serviceGroup ?? serviceUser;
  const workingDir = rawOptions.workingDir ?? dirname(configPath);
  const servicePath = rawOptions.servicePath ?? `/etc/systemd/system/${serviceName}.service`;
  const enableCapNetBind = rawOptions.enableCapNetBind ?? false;
  const additionalArgs = rawOptions.additionalArgs ?? [];
  const force = rawOptions.force ?? false;

  const bunBinary = await resolveBunBinary(rawOptions.bunBinary ?? Bun.env.BUN ?? undefined);

  const env: Record<string, string> = {
    NODE_ENV: "production",
    PATH: Bun.env.PATH ?? "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
    PROXY_CONFIG: configPath,
    ...(rawOptions.env ?? {}),
  };

  const runtimeArgs = ["--config", configPath, ...additionalArgs];
  const execArgs = [bunBinary, "start"];
  if (runtimeArgs.length > 0) {
    execArgs.push("--", ...runtimeArgs);
  }

  if (rawOptions.dryRun) {
    const unitFile = buildUnitFile({
      serviceName,
      serviceUser,
      serviceGroup,
      workingDir,
      env,
      execArgs,
      enableCapNetBind,
    });
    console.log(`# Dry run: would write ${servicePath}`);
    console.log(unitFile);
    return {
      servicePath,
      execStart: execArgs.join(" "),
      enabled: false,
      started: false,
    };
  }

  const unitFile = buildUnitFile({
    serviceName,
    serviceUser,
    serviceGroup,
    workingDir,
    env,
    execArgs,
    enableCapNetBind,
  });

  if (!force) {
    const existing = Bun.file(servicePath);
    if (await existing.exists()) {
      throw new Error(`Service file already exists at ${servicePath}. Pass --service-force to overwrite.`);
    }
  }

  await mkdir(dirname(servicePath), { recursive: true });
  await Bun.write(servicePath, unitFile);
  await chmod(servicePath, 0o644);

  const systemctl = await detectSystemctl();

  await Bun.$`${systemctl} daemon-reload`;
  await Bun.$`${systemctl} enable ${serviceName}`;
  await Bun.$`${systemctl} restart ${serviceName}`;

  console.log(`Installed service ${serviceName} using ${servicePath}`);
  console.log(`ExecStart: ${execArgs.join(" ")}`);

  return {
    servicePath,
    execStart: execArgs.join(" "),
    enabled: true,
    started: true,
  };
}
